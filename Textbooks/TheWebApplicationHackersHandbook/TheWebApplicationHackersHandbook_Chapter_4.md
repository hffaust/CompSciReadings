The Web Application Hackers Handbook Chapter 4

# Chapter 4: Mapping the Application
- The mapping exercise begins by enumerating the application’s content and functionality in order to understand what the application does and how it behaves. Much of this functionality is easy to identify, but some of it may be hidden, requiring a degree of guesswork and luck to discover.
	- Manual browsing is usually the a good starting option if the appication isn't overly large, however we will want to employ more advance techniques later to uncover the goods.
	-  If the application contains a “site map,” this can provide a useful starting point for enumerating content.

## Web Spidering 
- Various tools can perform automated spidering of websites. These tools work by requesting a web page, parsing it for links to other content, requesting these links, and continuing recursively until no new content is discovered.
- Some tools include: Burp Suite, WebScarab, Zed Attack Proxy, and CAT.
- If the target website contains a robots.txt file, do yourself a favor and always visit that shit LOL.
- Spiders are far from perfect, they will mishandle javascript, fill in invalid inputs, and are often not  able to properly handle the session credentials which may make them miss pages visible only to authenticated users... However, they are a decent starting point.
	- In some applications, running even a simple web spider that parses and requests links can be extremely dangerous. 
		- For example, an application may contain administrative functionality that deletes users, shuts down a database, restarts the server, and the like.

## User-Directed Spidering
- Here, the user walks through the application in the normal way using a standard browser, attempting to navigate through all the application’s functionality. As he does so, the resulting traffic is passed through a tool combining an intercepting proxy and spider, which monitors all requests and responses. 
	- The tool builds a map of the application, incorporating all the URLs visited by the browser. It also parses all the application’s responses in the same way as a normal application-aware spider and updates the site map with the content and functionality it discovers. 
	- The spiders within Burp Suite and WebScarab can be used in this way.

***
- **HACK STEPS: Spidering Webpages**
	1. Configure your browser to use either Burp or WebScarab as a local proxy (see Chapter 20 for specific details about how to do this if you’re unsure).
	2. Browse the entire application normally, attempting to visit every link/URL you discover, submitting every form, and proceeding through all multi-step functions to completion. Try browsing with JavaScript enabled and disabled, and with cookies enabled and disabled. Many applications can handle various browser configurations, and you may reach different content and code paths within the application.
	3. Review the site map generated by the proxy/spider tool, and identify
	any application content or functions that you did not browse manually. Establish how the spider enumerated each item. For example, in Burp Spider, check the Linked From details. Using your browser, access the item manually so that the response from the server is parsed by the proxy/spider tool to identify any further content. Continue this step recursively until no further content or functionality is identified.
	4. Optionally, tell the tool to actively spider the site using all of the already enumerated content as a starting point. To do this, first identify any URLs that are dangerous or likely to break the application session, and configure the spider to exclude these from its scope. Run the spider and review the results for any additional content it discovers.
	The site map generated by the proxy/spider tool contains a wealth of information about the target application, which will be useful later in identifying the various attack surfaces exposed by the application.
***

## Discovering Hidden Directories 
### Brute-Force Techinques 

- Burp Intruder (and DirBuster) can be used to iterate through a list of common directory names and capture details of the server’s responses, which can be reviewed to identify valid directories. 
	- A `302 Found` status code commonly indicates that accessing this link without some sort of authentication redirects the user to another page.
	- `400 Bad Request` - The application may use a custom naming scheme for directories and files within URLs, which a particular request has not complied with. 
		- More likely, however, is that the wordlist you are using contains some whitespace characters or other invalid syntax.
	- `401 Unauthorized` or `403 Forbidden` - his usually indicates that the requested resource exists but may not be accessed by any user, regardless of authentication status or privilege level. It often occurs when directories are requested, and you may infer that the directory exists.
	- `500 Internal Server Error` - During content discovery, this usually indicates that the application expects certain parameters to be submitted when requesting the resource.

### Inference from Published Content
- Most applications employ some kind of naming scheme for their content and functionality. By inferring from the resources already identified within the application, it is possible to fine-tune your automated enumeration exercise to increase the likelihood of discovering further hidden content.
- For Example: if you notice all resources in /auth start with a capital letter: `
	```
	http://eis/auth/ResetPassword
	http://eis/auth/RetrievePassword
	http://eis/auth/UpdatePassword
	```

### Use of Public Information
- Using Google Dorking techniques will often reveal a lot of info. 
- Also make sure to make use of the WayBack Machine at www.archive.org
- Some Pro Tips:
	- Browse to the last page of search results for a given query, and select Repeat the Search with the Omitted Results Included. By default, Google attempts to filter out redundant results by removing pages that it believes are sufficiently similar to others included in the results. Overriding this behavior may uncover subtly different pages that are of interest to you when attacking the application.
	- related:www.wahh-target.com returns pages that are “similar” to the target and therefore includes a lot of irrelevant material. However, it may also discuss the target on other sites, which may be of interest.
	- View the cached version of interesting pages, including any content that is no longer present in the actual application. In some cases, search engine caches contain resources that cannot be directly accessed in the application without authentication or payment.
	- Another public source of useful information about the target application is any posts that developers and others have made to Internet forums. There are numerous such forums in which software designers and programmers ask and answer technical questions.
***
- **HACK STEPS: Finding Potential Internal Leads**
1. Compile a list containing every name and e-mail address you can discover relating to the target application and its development. This should include any known developers, names found within HTML source code, names found in the contact information section of the main company website, and any names disclosed within the application itself, such as administrative staff.
2. Using the search techniques described previously, search for each identified name to find any questions and answers they have posted to Internet forums. Review any information found for clues about functionality or vulnerabilities within the target application.
***

### Levaraging the Web Server
- **Wikto**  (also Nikto) is an example of a tool that will help identify webserver specific pages when standard spidering and brute forcing fails. 
	- Wikto will reveal pages such as `http://eis/phpmyadmin/`
	- Note that with tools like Nikto, you can specify a target application using its domain name or IP address. If a tool accesses a page using its IP address, the tool treats links on that page that use its domain name as belonging to a different domain, so the links are not followed. This is reasonable, because some applications are virtually hosted, with multiple domain names sharing the same IP address. Ensure that you configure your tools with this fact in mind.

### Application Pages Versus Funcitonal Paths
-  Consider an application that is accessed using only requests of the following form:
	```
	POST /bank.jsp HTTP/1.1
	Host: wahh-bank.com
	Content-Length: 106
	servlet=TransferFunds&method=confirmTransfer&fromAccount=10372918&to
	Account=
	3910852&amount=291.23&Submit=Ok
	```
	- Here, every request is made to a single URL. 
	- The parameters to the request are used to tell the application what function to perform by naming the Java servlet and method to invoke. 
		- Further parameters provide the information to use in performing the function. 

***
- **HACK STEPS: Finding Pages Through Functional Paths**

1. Identify any instances where application functionality is accessed not by requesting a specific page for that function (such as /admin/editUser.jsp) but by passing the name of a function in a parameter (such as /admin.jsp?action=editUser).
2. Modify the automated techniques described for discovering URL-specified content to work on the content-access mechanisms in use within the application. For example, if the application uses parameters that specify servlet and method names, first determine its behavior when an invalid servlet and/or method is requested, and when a valid method is requested with other invalid parameters. Try to identify attributes of the server’s responses that indicate “hits” — valid servlets and methods. If possible, find a way of attacking the problem in two stages, first enumerating servlets and then methods within these. Using a method similar to the one used for URL-specified content, compile lists of common items, add to these by inferring from the names actually observed, and generate large numbers of requests based on these.
3. If applicable, compile a map of application content based on functional paths, showing all the enumerated functions and the logical paths and dependencies between them.
***

### Discovering Hidden Parameters
- Sometimes when it is detected that the application uses request parameters we can test to see if other parameters are can used to control the application’s logic in significant ways.
	- For example, an application may behave differently if the parameter debug=true is added to the query string of any URL. It might turn off certain input validation checks, allow the user to bypass certain access controls, or display verbose debug information in its response.

***
- **HACK STEPS: Detecting Hidden Parameters**
1. Using lists of common debug parameter names (debug, test, hide, source, etc.) and common values (true, yes, on, 1, etc.), make a large number of requests to a known application page or function, iterating through all permutations of name and value. For POST requests, insert the added parameter to both the URL query string and the message body.
Burp Intruder can be used to perform this test using multiple payload sets and the “cluster bomb” attack type (see Chapter 14 for more details).
2. Monitor all responses received to identify any anomalies that may indicate that the added parameter has had an effect on the application’s processing.
3. Depending on the time available, target a number of different pages or functions for hidden parameter discovery. Choose functions where it is most likely that developers have implemented debug logic, such as login, search, and file uploading and downloading.
***

## Analyzing the Applicaton
- Enumerating as much of the application’s content as possible is only one element of the mapping process. 
- Equally important is the task of analyzing the application’s functionality, behavior, and technologies employed to identify the key attack surfaces it exposes and to begin formulating an approach to probing the application for exploitable vulnerabilities.

- Key areas to investigate:
	- The application’s core functionality — the actions that can be leveraged to perform when used as intended
	- Other, more peripheral application behavior, including off-site links, error messages, administrative and logging functions, and the use of redirects
	- The core security mechanisms and how they function — in particular, management of session state, access controls, and authentication mechanisms and supporting logic (user registration, password change, and account recovery)
	- All the different locations at which the application processes user-supplied
	input — every URL, query string parameter, item of `POST` data, and cookie
	- The technologies employed on the client side, including forms, client-side scripts, thick-client components (Java applets, ActiveX controls, and Flash), and cookies
	- The technologies employed on the server side, including static and dynamic pages, the types of request parameters employed, the use of SSL, web server software, interaction with databases, e-mail systems, and other back-end components
	- Any other details that may be gleaned about the internal structure and functionality of the server-side application — the mechanisms it uses behind the scenes to deliver the functionality and behavior that are visible from the client perspective

### Identifying Entry POints for User Input
- Key locations to pay attention to:
	- Every URL string up to the query string marker
	- Every parameter submitted within the URL query string
	- Every parameter submitted within the body of a POST request
	- Every cookie
	- Every other HTTP header that the application might process — in particular, the User-Agent, Referer, Accept, Accept-Language, and Host headers


### URL File Paths
- In applications that use REST-style URLs, the parts of the URL that precede the query string can in fact function as data parameters and are just as important as entry points for user input as the query string itself.
- In this example, the strings electronics and iPhone3G should be treated as parameters to store a search function: `http://eis/shop/browse/electronics/iPhone3G/`

### Request Parameters

- Some Example of nonstandard parameters:
	- /dir/file;foo=bar&foo2=bar2
	- /dir/file?foo=bar$foo2=bar2
	- /dir/file/foo%3dbar%26foo2%3dbar2
	- /dir/foo.bar/file
	- /dir/foo=bar/file
	- /dir/file?param=foo:bar
	- /dir/file?data=%3cfoo%3ebar%3c%2ffoo%3e%3cfoo2%3ebar2%3c%2ffoo2%3e
- If a nonstandard parameter format is being used, you need to take this into account when probing the application for all kinds of common vulnerabilities.

### HTTP Headers
- Many applications perform custom logging functions and may log the contents of HTTP headers such as Referer and User-Agent. These headers should always be considered as possible entry points for input-based attacks.
	- In some situations you can perform successful attacks by adding further headers that the application may still process.

### Out-of-Band Channels
- Out-of-Band channels are pathways by which the application receives data that you may be able to control.
- Here are some examples of web applications that receive user-controllable data via an out-of-band channel:
	- A web mail application that processes and renders e-mail messages received via SMTP
	- A publishing application that contains a function to retrieve content via HTTP from another server
	- An intrusion detection application that gathers data using a network sniffer and presents this using a web application interface
	- Any kind of application that provides an API interface for use by non-browser user agents, such as cell phone apps, if the data processed via this interface is shared with the primary web application

## Identifying Server-Side Technologies
- Normally it is possible to fingerprint the technologies employed on the server via various clues and indicators.

### Banner Grabbing
- Many web servers disclose fine-grained version information, both about the web server software itself and about other components that have been installed. 
- For example, the HTTP Server header discloses a huge amount of detail about some installations:
	```
	Server: Apache/1.3.31 (Unix) mod_gzip/1.3.26.1a mod_auth_passthrough/
	1.8 mod_log_bytes/1.2 mod_bwlimited/1.4 PHP/4.3.9 FrontPage/
	5.0.2.2634a mod_ssl/2.8.20 OpenSSL/0.9.7a
	```
- In addition to the Server header, the type and version of software may be dis- closed in other locations:
	- Templates used to build HTML pages
	- Custom HTTP headers
	- URL query string parameters

### HTTP Fingerprinting
-  A web server can be fingerprinted in numerous subtle ways, other than via its Server banner. 
- Httprecon is a handy tool that performs a number of tests in an attempt to fingerprint a web server’s software.


### File Extensions
- File extensions used within URLs often disclose the platform or programming language used to implement the relevant functionality. 
- For example:
	- asp — Microsoft Active Server Pages
	- aspx — Microsoft ASP.NET
	- jsp — Java Server Pages
	- cfm — Cold Fusion
	- php — The PHP language
	- d2w — WebSphere
	- pl — The Perl language
	- py — The Python language
	- dll — Usually compiled native code (C or C++) 
	- nsf or ntf — Lotus Domino
- Even if an application does not employ a particular file extension in its published content, it is usually possible to verify whether the technology supporting that extension is implemented on the server. 
	- For example, if ASP.NET is installed, requesting a nonexistent .aspx file returns a customized error page generated by the ASP.NET framework

- Another common fingerprint to be aware of are URLs that look like this: `https://wahh-app/news/0,,2-421206,00.html`
	- The comma-separated numbers toward the end of the URL are usually generated by the Vignette content management platform.

### Directory Names
- It is common to encounter subdirectory names that indicate the presence of an associated technology. 
- For example:
	- servlet — Java servlets
	- pls — Oracle Application Server PL/SQL gateway
	- cfdocs or cfide — Cold Fusion
	- SilverStream — The SilverStream web server
	- WebObjects or {function}.woa — Apple WebObjects 
	- rails — Ruby on Rails

### Session Tokens
- Many web servers and web application platforms generate session tokens by default with names that provide information about the technology in use. 
- For example:
	- JSESSIONID — The Java Platform
	- ASPSESSIONID — Microsoft IIS server
	- ASP.NET_SessionId — Microsoft ASP.NET
	- CFID/CFTOKEN — Cold Fusion
	- PHPSESSID — PHP

## Mapping the Attack Surface
- The following is a rough guide to some key types of behavior and functionality that you may identify, and the kinds of vulner- abilities that are most commonly found within each one:

|Feature|Commonly Associated Vulnerability|
|:---:|:---:|
|Client-side validation|Checks may not be replicated on the server|
|Database interaction|SQL injection|
|File uploading and downloading|Path traversal vulnerabilities, stored cross-site scripting|
|Display of user-supplied data|Cross-site scripting|
|Dynamic redirects|Redirection and header injection attacks|
|Social networking features|username enumeration, stored cross-site scripting|
|Login|Username enumeration, weak passwords, ability to use brute force|
|Multistage login|Logic flaws|
|Session state|Predictable tokens, insecure handling of tokens|
|Access controls|Horizontal and vertical privilege escalation|
|User impersonation functions|Privilege escalation|
|Use of cleartext communications|Session hijacking, capture of credentials and other sensitive data|
|Off-site links|Leakage of query string parameters in the Referer header|
|Interfaces to external systems|Shortcuts in the handling of sessions and/or access controls|
|Error messages|Information leakage|
|E-mail interaction|E-mail and/or command injection|
|Native code components or interaction|Buffer overflows|
|Use of third-party application components|Known vulnerabilities|
|Identifiable web server software|Common configuration weaknesses, known software bugs|

***
- **HACK STEPS: Mapping Apps 101**
1. Understand the core functionality implemented within the application and the main security mechanisms in use.
2. Identify all features of the application’s functionality and behavior that are often associated with common vulnerabilities.
3. Check any third-party code against public vulnerability databases such as www.osvdb.org to determine any known issues.
4. Formulate a plan of attack, prioritizing the most interesting-looking functionality and the most serious of the associated potential vulnerabilities.
***

